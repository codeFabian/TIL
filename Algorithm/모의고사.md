## 프로그래머스, 모의고사

문제 설명
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한 조건
시험은 최대 10,000 문제로 구성되어있습니다.
문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.


## 조건

- number 타입을 요소로 갖는 배열을 리턴해야 합니다.  
- 배열의 요소는 오름차순으로 정렬되어야 합니다.  
- arr[i] <= arr[j] (i < j)

<br/>

|     input     | output |
| :-----------: | :----: |
| [1, 2, 3, 4, 5] | [1] |
| [1, 3, 2, 4, 2] | [1, 2, 3] |

<br/>

### Code

```js
function solution(answers) {
    let result = []
    let counter = [0, 0, 0];
    
    let first = [1,2,3,4,5];
    let second = [2, 1, 2, 3, 2, 4, 2, 5];
    let third = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    
    for(let i = 0; i< answers.length; i++) {
        if(answers[i] === first[i % 5]) {
            counter[0]++;
        }
        if(answers[i] === second[i % 8]) {
            counter[1]++;
        }
        if(answers[i] === third[i % 10]) {
            counter[2]++;
        }
    }
    
    let max = 0;
    for(let j = 0; j < counter.length; j++) {
        if(counter[j] > max) {
            max = counter[j]
        }
    }
    for(let k = 0; k< counter.length; k++) {
        if(max === counter[k]) {
            result.push(k+1)
        }
    }
    return result;
}
```

<br />

## 풀이

1. 1번, 2번, 3번 수포자들의 정답 개수에 해당하는 counter 배열을 만들어준다. 초기값은 [0,0,0] 
2. 정답으로 들어오는 배열 answers 를 반복문으로 돌리면서 1,2,3 수포자들의 배열과 비교한다.
3. 정답 배열의 인덱스의 값과, 수포자들의 배열의 인덱스의 값이 일치하는 경우 counter 에 해당 수포자의 인덱스 값을 ++ 한다.
4. max라는 가장많이 맞춘 것을 의미할 변수를 선언한 뒤에
5. 배열 counter 를 조회하여 가장 큰 값을 max 로 만들어준다.
6. 다시 반복문을 통하여 max와 일치하는 수포자를 최종 리턴할 배열에 넣어서 호출한다. 
7. 여기서 counter 는 1번, 2번, 3번에 해당하는 수포자를 의미했지만 [0,0,0] 의 초기값이였기 때문에 +1을 해주어 push를 해야한다.
